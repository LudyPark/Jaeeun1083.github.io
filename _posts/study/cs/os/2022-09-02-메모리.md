---
title: 메모리
author: jaeeun
date: 2022-09-02 00:00:00 +0800
categories: [Study, "Operating System"]
tags: ["Operating System"]
render_with_liquid: false
---

스터디 Stacked-Book에서 실습과 그림으로 배우는 리눅스 구조 책을 참고하여 학습 후 정리한 글입니다.

## 주소 바인딩

- 프로그램이 실행을 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다. 이 주소를 **논리적 주소(= 가상 주소)** 라고 부른다.
  - CPU는 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.
  - 논리적 주소는 각 프로세스마다 독립적으로 할당되며 보통 0번지부터 시작된다.
- **물리적 주소**란 물리적 메모리에 실제로 올라가는 위치를 말한다.
- CPU가 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소를 물리적 메모리 주소로 연결시켜 주는 작업을 **주소 바인딩**이라고 한다.

### 주소 바인딩 방법

<img src="https://user-images.githubusercontent.com/78838791/188034090-9c9338e2-861a-4595-b394-277a034d6371.png" width="500px">

- 프로그램이 적재되는 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.
  - 컴파일 타임 바인딩 : 물리적 메모리 주소가 프로그램 컴파일 시 해당 프로그램이 물리적 메모리 어디에 위치할 지 절대 주소가 결정된다.
  - **로드 타임 바인딩** : 프로그램의 실행이 시작될 때 물리적 메모리 주소가 결정된다. 로더의 책임 하에 물리적 메모리 주소가 부여되며 프로그램 종료 시까지 물리적 메모리 상의 위치가 고정된다.
  - **실행시간 바인딩** : CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리 어느 위치에 존재해야하는지 주소 매핑 테이블을 이용해 바인딩을 점검한다. base register와 limit register를 포함해 MMU가 필요하다.

### MMU 기법

<img src="https://user-images.githubusercontent.com/78838791/188034519-9bb51e3d-ce01-4503-98b6-20489d86518d.png" width="500px">

- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 base register 값을 더해 물리 주소값을 얻어낸다.
- 따라서 CPU가 특정 논리적 주소를 참조한다고 했을 때 현재 CPU에서 수행되고 있는 프로세스에 따라 가리키는 내용이 상이해진다.
- CPU가 요청한 논리적 주소값이 lmit register 내에 저장된 프로세스의 크기보다 작은지 확인한다. 작다면 논리적 주소 값에 base register 값을 더해 물리적 주소를 구한 다음 물리적 메모리 위치에 접근을 허락한다.

## 물리적 메모리 할당 방식
- 물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉜다.
  - 운영체제 상주 영역은 인터럽트 벡터와 물리적 메모리의 낮은 주소 영역을 사용하며 운영체제 커널이 여기 위치한다.
  - 사용자 프로세스 영역은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.
- 사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 물리적 메모리를 메모리의 연속적인 공간에 올리는 **연속할당 방식**과
  하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 **불연속할당 방식**으로 나뉜다.

### 연속 할당 방식

#### 고정분할 방식
- **물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누고 각 분할에 하나의 프로세스를 적재해 실행**시킨다. 이 때 분할의 크기는 모두 동일하게 할 수도 다르게 할 수도 있다.
- 이 때 외부 단편화와 내부 단편화가 발생할 수 있다.
- **외부 단편화** : 프로그램의 크기보다 분할의 크기가 작은 경우 적재할 수 없어 발생하는 메모리 공간을 뜻한다.
- **내부 단편화** : 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 뜻한다.

#### 가변분할 방식
- 고정분할 방식과 달리 메모리에 적재되는 프로그램 크기에 따라 분할 크기, 개수가 동적으로 변하는 방식이다.
- 내부 단편화는 발생하지 않으나 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하며
  이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부 단편화가 발생할 수 있다.
  - 이를 해결하기 위해 물리적 메모리 중 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 컴팩션(compaction)이 있다.
- 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 지를 결정하는 **동적 메모리 할당 문제**가 있다.
  - 이를 해결하는 방법은 first-fit, best-fit, worst-fit 방법이 있다.

### 불연속할당 방식
#### 페이징
  - **프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장**하는 방식이다.
  - 물리적 메모리를 페이지와 동일한 크기의 프레임으로 미리 나누어 두고 빈 프레임이 있으면 페이지를 할당한다.
  - 하나의 프로세스더라도 페이지 단위로 물리적 메모리에 올리는 위치가 상이하므로 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이뤄진다.
    - 모든 프로세스가 각각의 주소 변환을 위한 **페이지 테이블**을 가진다.
    - 페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 보호비트(각 페이지에 대한 읽기-쓰기/읽기전용 등의 접근 권한)와 유효-무효 비트(해당 페이지의 내용이 유효한 지)가 있다.
  - 메모리상의 가용 공간의 크기가 작아서 빈 공간임에도 활용되지 못하는 외부 단편화는 발생하지 않으나 프로세스 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부단편화가 발생할 가능성이 있다.
#### 세그멘테이션
  - **프로세스의 주소 공간을 의미 단위의 세그먼트로 나누어 물리적 메모리에 올리는 방식**이다.
  - 프로세스 주소 공간은 코드, 데이터, 스택 등의 단위로 구성되며 세그먼트는 이 주소 공간을 기능 단위 혹은 의미 단위로 나눈 것이다. 이 때 세그먼트는 의미를 가질 수 있는 논리적 단위로 나눈 것이므로 그 크기가 균일하지 않다.
  - 주소 변환을 위해 세그먼트 테이블을 사용하며 각 항목은 기준점(세그먼트의 시작 위치)과 한계점(세그먼트의 길이)을 가지고 있다.
#### 페이지드 세그멘테이션
  - 앞선 두 기법의 장점을 취한 기법으로 세그멘테이션 개념과 동일하게 프로그램을 의미 단위의 세그먼트로 나눈다. 이 때 길이는 반드시 동일한 크기 페이지들의 집합이다.
  - 물리적 메모리에 적재하는 단위는 페이지 단위이다.
  - **하나의 세그먼트 크기를 페이지 크기의 배수가 되도록하여 세그멘테이션 기법에서 발생하는 외부 단편화의 문제점을 해결하며 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 하여 페이징 기법의 약점을 해소**한다.

## 페이지 폴트는 무엇이며 언제발생하나요? 페이지폴트가 발생할때 운영체제가 어떤 조치를 취할까요

### 요구 페이징

- 프로그램 실행 중에 추가적인 페이지를 요구할 때 페이지를 적재하는 방법이다. 특정 페이지에 대해 CPU의 요청이 들어온  후에 해당 페이지를 메모리에 적재한다.
- 실행 중인 부분이 메모리에 올라가 있다면 나머지 부분은 보조 기억 장치에 있다는 뜻이므로 유효-무효 비트를 여기에 적용한다.
- **유효한 상태**는 연관된 페이지가 합법인 페이지며 메모리 위에 있다는 의미이다.
- **무효한 상태**는 페이지가 프로세스의 가상 주소 공간에 속하지 않거나 (무효하거나) 유효하나 현재 보조 기억 장치에 있다는 의미로 사용한다.

### 페이지 폴트

<img src="https://user-images.githubusercontent.com/78838791/188038035-306119d9-7e00-4ca2-b3b9-6c363007ac2c.png" width="500px">

- CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 유효-무효 비트가 무효로 세팅되어 있는 경우를 페이지 폴트가 일어났다고 한다.

### 페이지 폴트를 처리하는 방법

- 가상메모리 사용을 가정하고 설명한다.. 가상 메모리 기법에서는 프로세스가 실행되는 동안 일부 페이지만 메모리에 올라와 있고 나머지 페이지는 디스크의 스왑 영역에 존재한다.

<img src="https://user-images.githubusercontent.com/78838791/188038216-cea7dbb5-1d2d-44aa-b496-391e829636ef.png" width="500px">

- CPU가 무효 페이지에 접근하면 주소 변환을 담당하는 하드웨어인 **MMU가 페이지 폴트 트랩을 발생**시킨다.
- CPU의 제어권이 **커널모드로 전환되고 운영체제의 페이지 폴트 처리 루틴이 호출**된다.
  - 운영체제는 **해당 페이지에 대한 접근이 적법한지** 먼저 체크한다.
  - 사용되지 않는 주소 영역에 속한 페이지 접근이거나 해당 페이지에 대한 접근 권한 위반일 경우 해당 프로세스를 종료시킨다.
  - 해당 페이지 접근이 적법하다면 **물리적 메모리에서 비어 있는 프레임을 할당받아 그 공간에 해당 페이지를 읽어온다.**
  - 만약 비어있는 프레임이 없다면 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아낸다. (스왑 아웃)
  - 요청된 페이지를 디스크에서 메모리로 적재하는 데에는 시간이 걸리므로 **페이지 폴트를 발생시킨 프로세스는 CPU를 빼앗기고 봉쇄 상태가 된다.**
  - 이 때 현재까지 수행되던 CPU 레지스터 상태 및 프로그램 카운터 값을 **PCB에 저장**해두어 나중에 이 프로세스가 다시 CPU를 할당 받았을 때 다음 명령을 수행할 수 있도록 한다.
- 디스크 입출력이 완료되어 인터럽트가 발생하면 페이지 테이블에서 **해당 페이지의 유효-무효 비트를 유효로 설정하고 봉쇄되었던 프로세스를 준비 큐로 이동**시킨다.
- **프로세스가 CPU를 할당 받으면** PCB에 저장해두었던 값을 복원시켜 이전에 중단되었던 명령부터 **실행을 재개**한다.
