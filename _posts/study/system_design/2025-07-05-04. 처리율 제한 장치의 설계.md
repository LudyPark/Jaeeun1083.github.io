---
title: System Design. Part04. ì²˜ë¦¬ìœ¨ ì œí•œ ì¥ì¹˜ì˜ ì„¤ê³„
author: jaeeun
date: 2023-03-17 00:00:00 +0800
categories: [Study, "SystemDesign"]
tags: ["System Design"]
render_with_liquid: false
---

# Part04. ì²˜ë¦¬ìœ¨ ì œí•œ ì¥ì¹˜ì˜ ì„¤ê³„

### ì²˜ë¦¬ìœ¨ ì œí•œ ì¥ì¹˜ë€?
- API ì„œë²„, ì›¹ ì„œë¹„ìŠ¤ ë“±ì—ì„œ ì§€ë‚˜ì¹˜ê²Œ ë§ì€ ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì¼ì • ì‹œê°„ ë™ì•ˆ í—ˆìš©í•˜ëŠ” ìš”ì²­ ìˆ˜ë¥¼ ì œí•œí•˜ëŠ” ê¸°ëŠ¥ì´ë‹¤.

### ì²˜ë¦¬ìœ¨ ì œí•œ ë°©ì‹ 3ê°€ì§€ ë¹„êµ

| êµ¬ë¶„ | ğŸ§ í´ë¼ì´ì–¸íŠ¸| ì„œë²„ | ë¯¸ë“¤ì›¨ì–´(API Gateway ë“±) |
|-----|-----------|-----|-----------------------|
| **ìš”ì²­ ì²˜ë¦¬ ì‹œì ** | ìš”ì²­ *ì „* ì°¨ë‹¨ | ì„œë²„ ë‚´ë¶€ì—ì„œ ì°¨ë‹¨ | ì„œë²„ *ë„ë‹¬ ì „* ì°¨ë‹¨ |
| **ì¥ì ** | - ì„œë²„ ë¶€í•˜ ê°ì†Œ<br>- ì™¸ë¶€ API ìš”ê¸ˆ ë°©ì§€ | - ì‚¬ìš©ì/ìš”ê¸ˆì œë³„ ì„¸ë°€ ì œì–´ | - ê³¼ë¶€í•˜ íš¨ê³¼ì ìœ¼ë¡œ ì°¨ë‹¨<br>- ì¸ìŠ¤í„´ìŠ¤ ê°„ ì¼ê´€ì„± ìœ ì§€ |
| **ë‹¨ì ** | - ìš°íšŒ ê°€ëŠ¥ (ì‹ ë¢° ë¶ˆê°€)<br>- ë³´ì•ˆ ì·¨ì•½ | - ì„œë²„ ë¦¬ì†ŒìŠ¤ ì†Œë¹„ í›„ ê±°ë¶€<br>- ë¶„ì‚° í™˜ê²½ì—ì„  ìƒíƒœ ê³µìœ  í•„ìš” | - êµ¬ì„± ë³µì¡ì„± ë° ìš´ì˜ ë¹„ìš© ì¦ê°€ |
| **ì‚¬ìš© ì˜ˆ** | - ë²„íŠ¼ ì—°íƒ€ ë°©ì§€<br>- ì™¸ë¶€ API í˜¸ì¶œ ì œí•œ | - í† í°ë‹¹ ìš”ì²­ ìˆ˜ ì œí•œ<br>- ë¡œê·¸ì¸ ì‹œë„ ì œí•œ | - ì „ì²´ ì‹œìŠ¤í…œ íŠ¸ë˜í”½ ì œí•œ<br>- IPë³„ ìš”ì²­ ìˆ˜ ì œí•œ 

---

### ì²˜ë¦¬ìœ¨ ì œí•œ ì•Œê³ ë¦¬ì¦˜


#### 1. í† í° ë²„í‚· ì•Œê³ ë¦¬ì¦˜
##### ì›ë¦¬
- í† í°ì€ ì •í•´ì§„ ì†ë„ë¡œ ë²„í‚·ì— ì§€ì†ì ìœ¼ë¡œ ì¶”ê°€ë¨.
- ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´ ë²„í‚·ì—ì„œ í† í°ì„ í•˜ë‚˜ì”© ì†Œë¹„í•¨.
- í† í°ì´ ì—†ìœ¼ë©´ ìš”ì²­ì„ ê±°ë¶€í•˜ê±°ë‚˜ íì— ë„£ì–´ ëŒ€ê¸°í•¨.

##### í•µì‹¬ ìš”ì†Œ
- capacity (ë²„í‚· í¬ê¸°): ìµœëŒ€ ë³´ìœ  ê°€ëŠ¥í•œ í† í° ê°œìˆ˜ (burst í—ˆìš©ëŸ‰ ê²°ì •)
- refill rate (ë³´ì¶© ì†ë„): ë‹¨ìœ„ ì‹œê°„ ë‹¹ í† í° ì¶”ê°€ ì†ë„ (ì§€ì† ê°€ëŠ¥í•œ ì²˜ë¦¬ëŸ‰)

##### ğŸ“ ì˜ˆì‹œ
- capacity: 10ê°œ, refill rate: ì´ˆë‹¹ 1ê°œ
  - ìˆœê°„ì ìœ¼ë¡œ ìµœëŒ€ 10ê°œì˜ ìš”ì²­ ì²˜ë¦¬ ê°€ëŠ¥, ê·¸ í›„ ì´ˆë‹¹ 1ê°œì”© ì²˜ë¦¬ ê°€ëŠ¥

##### âœ… ì¥ì 
- ìˆœê°„ì ì¸ íŠ¸ë˜í”½ ì¦ê°€ í—ˆìš© (ìš”ì²­ì´ ëª°ë¦¬ë©´ ê·¸ ë²„í‚·ì— ë‚¨ì•„ìˆëŠ” í† í°ë§Œí¼ í•œêº¼ë²ˆì— ì†Œë¹„í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
- ë²„í‚· í¬ê¸°(capacity)ì™€ í˜„ì¬ í† í° ìˆ˜(tokens), ë§ˆì§€ë§‰ ë³´ì¶© ì‹œì (timestamp) ì •ë„ë§Œ ì €ì¥í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì— íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©

##### âš ï¸ ë‹¨ì 
- ë‘ê°œì˜ ì¸ì (ë²„í‚· í¬ê¸°, í† í° ê³µê¸‰ë¥ )ì„ íŠœë‹í•˜ëŠ”ê²Œ ê¹Œë‹¤ë¡œì›€

```Kotlin
class TokenBucketRateLimiter(
    private val capacity: Int,              // ë²„í‚·ì´ ìµœëŒ€ ë³´ìœ í•  ìˆ˜ ìˆëŠ” í† í° ìˆ˜
    private val refillRatePerSecond: Double // ì´ˆë‹¹ ë²„í‚·ì— ë³´ì¶©í•  í† í° ìˆ˜
) {
    private var tokens: Double = capacity.toDouble()           // í˜„ì¬ ë‚¨ì•„ìˆëŠ” í† í° ìˆ˜
    private var lastRefillTimestamp: Long = System.currentTimeMillis() // ë§ˆì§€ë§‰ ë³´ì¶© ì‹œì 
    private val lock = ReentrantLock()

    init {
        // ë°±ê·¸ë¼ìš´ë“œ íƒ€ì´ë¨¸: (1000ms / refillRatePerSecond) ê°„ê²©ìœ¼ë¡œ refillTokens() í˜¸ì¶œ
        val intervalMillis = (1000L / refillRatePerSecond).toLong().coerceAtLeast(1L)
        fixedRateTimer(period = intervalMillis, daemon = true) {
            lock.withLock { refillTokens() }
        }
    }

    /**
     * ìš”ì²­ í—ˆìš© ì—¬ë¶€ íŒë‹¨
     */
    fun allowRequest(): Boolean {
        lock.withLock {
            return if (tokens >= 1) {
                tokens -= 1
                true
            } else {
                false
            }
        }
    }

    /**
     * ê²½ê³¼ ì‹œê°„ë§Œí¼ í† í° ë³´ì¶©
     */
    private fun refillTokens() {
        val now = System.currentTimeMillis()
        val elapsedMillis = now - lastRefillTimestamp // ê²½ê³¼ ì‹œê°„ ê³„ì‚°
        val tokensToAdd = elapsedMillis / 1000.0 * refillRatePerSecond // ê²½ê³¼ ì‹œê°„ * ì‹œê°„ ë‹¹ ë³´ì¶©í•  í† í° ìˆ˜
        tokens = min(capacity.toDouble(), tokens + tokensToAdd) // ê¸°ì¡´ tokens ì— tokensToAdd ë¥¼ ë”í•˜ë˜ capacityë¥¼ ë„˜ì§€ ì•Šë„ë¡ minìœ¼ë¡œ ì œí•œ
        lastRefillTimestamp = now
    }
}
```

#### 2. ëˆ„ì¶œ ë²„í‚·
##### ì›ë¦¬
- ìš”ì²­ì´ ì˜¤ë©´ ë²„í‚·(queue)ì— ë“¤ì–´ê°€ê³ , ì²˜ë¦¬ ì‹œìŠ¤í…œì€ ê³ ì •ëœ ì†ë„ë¡œ ì²˜ë¦¬í•¨.
- ìš”ì²­ ì²˜ë¦¬ìœ¨ì´ ê³ ì •ë˜ì–´ ìˆì–´ ë²„í‚·ì´ ê°€ë“ ì°¨ë©´ ì¶”ê°€ ìš”ì²­ì€ ì¦‰ì‹œ ê±°ë¶€ë¨.

##### í•µì‹¬ ìš”ì†Œ
- queue size (ë²„í‚· í¬ê¸°): ìµœëŒ€ ë³´ê´€ ê°€ëŠ¥í•œ ìš”ì²­ ìˆ˜
- leak rate (ëˆ„ì¶œ ì†ë„): ìš”ì²­ ì²˜ë¦¬ ì†ë„ (ê³ ì •ë¨)

##### ğŸ“ ì˜ˆì‹œ
- queue size: 10, leak rate: ì´ˆë‹¹ 1ê°œ
  - ì´ˆë‹¹ 1ê°œì”© ìš”ì²­ ì²˜ë¦¬, ìš”ì²­ì´ ì´ˆë‹¹ 2ê°œì”© ì˜¤ë©´ ì ì°¨ ì°¨ì„œ ê²°êµ­ ì°¨ë‹¨ë¨

##### âœ… ì¥ì 
- íì˜ í¬ê¸°ê°€ ì œí•œë˜ì–´ ìˆì–´ íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©
- ê³ ì •ëœ ì²˜ë¦¬ìœ¨ì„ ê°–ê³  ìˆì–´ ì•ˆì •ì ì¸ ì²˜ë¦¬ìœ¨ë¡œ ì„œë²„ ë³´í˜¸ì— íƒì›”

##### âš ï¸ ë‹¨ì 
- ìˆœê°„ì ì¸ íŠ¸ë˜í”½ í—ˆìš© ì–´ë ¤ì›€
- queueì— ì ì²´ë  ê²½ìš° latency(ì§€ì—° ì‹œê°„) ì¦ê°€ ê°€ëŠ¥

```Kotlin
/**
 * ìš”ì²­ì„ íì— ì €ì¥í•˜ê³  ê³ ì • ì†ë„ë¡œ ì²˜ë¦¬ (ëˆ„ì¶œ)
 * íê°€ ê°€ë“ ì°¨ë©´ ì¶”ê°€ ìš”ì²­ì€ ê±°ì ˆ
 */
class LeakyBucketRateLimiter(
    private val queueSize: Int, // í(ë²„í‚·)ê°€ ë³´ê´€í•  ìµœëŒ€ ìš”ì²­ ìˆ˜
    leakRatePerSecond: Int, // ì´ˆë‹¹ ì²˜ë¦¬(ëˆ„ì¶œ)í•  ìš”ì²­ ìˆ˜
) {
    private val queue: Queue<Long> = LinkedList()
    private val leakIntervalMillis = 1000L / leakRatePerSecond

    init {
        fixedRateTimer(period = leakIntervalMillis, daemon = true) {
            processOne()
        }
    }

    /**
     * ìš”ì²­ ì¶”ê°€ ì‹œë„
     * @param requestId ìš”ì²­ ì‹ë³„ì
     */
    @Synchronized
    fun allowRequest(requestId: Long): Boolean {
        return if (queue.size < queueSize) {
            queue.add(requestId)
            true
        } else {
            false
        }
    }

    /** í•˜ë‚˜ì˜ ìš”ì²­ì„ íì—ì„œ êº¼ë‚´ ì²˜ë¦¬ */
    @Synchronized
    private fun processOne() {
        queue.poll()?.let { id ->
            println("Processing request: $id")
        }
    }
}

```

#### 3. ê³ ì • ìœˆë„ ì¹´ìš´í„°

##### ì›ë¦¬
- ì¼ì •í•œ ì‹œê°„ ê°„ê²©ì˜ ìœˆë„(ì˜ˆ: ë§¤ 1ë¶„)ë¥¼ ì •í•´ë‘ê³ , ê·¸ ì•ˆì—ì„œ ìš”ì²­ ìˆ˜ë¥¼ ì„¸ì„œ ì œí•œí•¨.
- ìœˆë„ê°€ ëë‚˜ë©´ ì¹´ìš´íŠ¸ ë¦¬ì…‹

##### í•µì‹¬ ìš”ì†Œ
- window size: ìœˆë„ì˜ ì‹œê°„ ê°„ê²©
- threshold: ìœˆë„ ë‚´ ìµœëŒ€ í—ˆìš© ìš”ì²­ ìˆ˜

##### ğŸ“ ì˜ˆì‹œ
- window size: 1ë¶„, request limit: 100
  - â†’ ë§¤ ë¶„ë‹¹ 100ê°œì˜ ìš”ì²­ë§Œ í—ˆìš©. ìœˆë„ê°€ ëë‚˜ë©´ ì¹´ìš´íŠ¸ 0ìœ¼ë¡œ ì´ˆê¸°í™”

##### âœ… ì¥ì 
- êµ¬í˜„ ê°€ì¥ ê°„ë‹¨í•˜ê³  ë©”ëª¨ë¦¬ ì†Œëª¨ ìµœì†Œ
- ë¹ ë¥´ê³  ê°„ë‹¨í•œ ì œì–´

##### âš ï¸ ë‹¨ì 
- ì¹´ìš´í„° ì´ˆê¸°í™” ì‹œì ì´ ê³ ì •ëœ êµ¬ê°„ ê²½ê³„ì—ë§Œ ì¼ì–´ë‚˜ê¸°ë•Œë¬¸ì— **ìœˆë„ ê²½ê³„ ë¬¸ì œ ë°œìƒ** (e.g. 59ì´ˆ~60ì´ˆ ì‚¬ì´ ë§ì€ ìš”ì²­ì´ ëª°ë¦¬ë©´, ìµœëŒ€ 2ë°° ìš”ì²­ í—ˆìš© ê°€ëŠ¥)

```Kotlin
/**
 * ê³ ì •ëœ ì‹œê°„ ìœˆë„ìš°ë§ˆë‹¤ ì¹´ìš´íŠ¸ë¥¼ ì´ˆê¸°í™”í•˜ê³  ì œí•œ
 */
class FixedWindowRateLimiter(
    private val windowSizeMillis: Long, // ìœˆë„ìš° í¬ê¸° (ms)
    private val maxRequests: Int, // ìœˆë„ìš° ë‚´ í—ˆìš© ìµœëŒ€ ìš”ì²­ ìˆ˜
) {
    // í˜„ì¬ ìœˆë„ìš° ì‹œì‘ ì‹œê° (ì´ˆê¸°ì—ëŠ” ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹œì )
    private var windowStart: Long = System.currentTimeMillis()
    private var count: Int = 0

    /**
     * ìš”ì²­ í—ˆìš© ì—¬ë¶€ íŒë‹¨
     */
    @Synchronized
    fun allowRequest(): Boolean {
        val now = System.currentTimeMillis()

        // 1 í˜„ì¬ ì‹œê°ì´ ìœˆë„ìš° ì‹œì‘ ì‹œê°(windowStart)ì—ì„œ windowSizeMillisë§Œí¼ ì§€ë‚¬ëŠ”ì§€ í™•ì¸
        if (now - windowStart >= windowSizeMillis) {
            // ìœˆë„ìš°ê°€ ë§Œë£Œëìœ¼ë¯€ë¡œ ìƒˆë¡œìš´ ìœˆë„ìš° ì‹œì‘ ì‹œê°ì„ í˜„ì¬ ì‹œê°ìœ¼ë¡œ ê°±ì‹ 
            // countë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”
            windowStart = now
            count = 0
        }
        return if (count < maxRequests) {
            count++
            true
        } else {
            false
        }
    }
}
```

#### 4. ì´ë™ ìœˆë„ ë¡œê·¸(Sliding Window Log)

#####  ì›ë¦¬
- ìš”ì²­ ë°œìƒ ì‹œ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ëª¨ë‘ ë¡œê·¸ì— ê¸°ë¡í•¨.
- ìš”ì²­ ì œí•œ ì²´í¬ ì‹œ, í˜„ì¬ ì‹œê°„ì—ì„œ ìœˆë„ í¬ê¸°ë§Œí¼ ê³¼ê±°ì˜ ìš”ì²­ ë¡œê·¸ë§Œ í™•ì¸í•˜ì—¬ íŒë‹¨.

#####  í•µì‹¬ ìš”ì†Œ
- window size: íŒë‹¨ì— ì“°ì¼ ì‹œê°„ ìœˆë„ í¬ê¸° (e.g. ìµœê·¼ 1ë¶„)
- log storage: ëª¨ë“  ìš”ì²­ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ì €ì¥

##### ğŸ“ ì˜ˆì‹œ
- window size: 1ë¶„, request limit: 100
  - â†’ ìš”ì²­ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ ìµœê·¼ 1ë¶„ ë¡œê·¸ë¥¼ ì²´í¬í•´ì„œ, 100ê±´ ì´ˆê³¼ë©´ ì°¨ë‹¨

##### âœ… ì¥ì 
- ì •ë°€ë„ ê°€ì¥ ë†’ìŒ

##### âš ï¸ ë‹¨ì 
- ìš”ì²­ ìˆ˜ ë§ì„ ì‹œ ë©”ëª¨ë¦¬ ë° ì²˜ë¦¬ ë¹„ìš© ì¦ê°€ (ë¡œê·¸ ê´€ë¦¬ ë¶€ë‹´)

```Kotlin
/**
 * ëª¨ë“  ìš”ì²­ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê¸°ë¡í•˜ê³ , ìœˆë„ìš° ë‚´ ë¡œê·¸ ìˆ˜ë¡œ ì œí•œ
 */
class SlidingWindowLogRateLimiter(
    private val windowSizeMillis: Long, // ìœˆë„ìš° í¬ê¸°
    private val maxRequests: Int, // ìœˆë„ìš° ë‚´ í—ˆìš©í•  ìµœëŒ€ ìš”ì²­ ìˆ˜
) {
    private val timestamps: Queue<Long> = LinkedList()  // ìš”ì²­ì´ ë“¤ì–´ì˜¨ ì‹œê°ë“¤ì„ ì €ì¥í•˜ëŠ” í
    private val lock = ReentrantLock()

    fun allowRequest(): Boolean {
        lock.withLock {
            val now = System.currentTimeMillis()

            // ìœˆë„ìš° ë°”ê¹¥(= now - windowSizeMillis ì´ì „) ìš”ì²­ë“¤ ì œê±°
            while (timestamps.isNotEmpty() && now - timestamps.peek() > windowSizeMillis) {
                timestamps.poll()
            }
            
            // ì²˜ë¦¬ ë°©ì‹ì—ëŠ” 2ê°€ì§€ ë°©ì‹ì´ ìˆëŠ” ê²ƒ ê°™ë‹¤.

            // 1ë²ˆ. í•­ìƒ ê¸°ë¡ (ì¹´ìš´íŠ¸ í¬í•¨ â†’ ì²˜ë¦¬ìœ¨ ê°ì†Œ (ë³´ìˆ˜ì ))
            timestamps.add(now)
            return timestamps.size <= maxRequests

            // 2ë²ˆ. ê±°ë¶€ëœ ì‹œë„ ë¯¸í¬í•¨ â†’ ì²˜ë¦¬ìœ¨ ìœ ì§€
            if (timestamps.size < maxRequests) {
                timestamps.add(now)
                return true
            } else {
                return false
            }
        }
    }
}
```

#### 5. ì´ë™ ìœˆë„ ì¹´ìš´í„°(Sliding Window Counter)

##### ì›ë¦¬
- ì „ì²´ ìœˆë„ë¥¼ ê³ ì • êµ¬ê°„ìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•Šê³ , í˜„ì¬ ìœˆë„ì™€ ì§ì „ ìœˆë„ì˜ ì¹´ìš´íŠ¸ë¥¼ ê°€ì¤‘í•©ì‚°í•´ ì§€ê¸ˆ ê¸°ì¤€ ì§€ë‚œ ì‹œê°„ ë§Œí¼ì˜ ìš”ì²­ëŸ‰ì„ ì¶”ì •

#####  í•µì‹¬ ìš”ì†Œ
- window size (ì „ì²´ ìœˆë„)
- max request (ìœˆë„ ë‚´ í—ˆìš©í•  ìµœëŒ€ ìš”ì²­ ìˆ˜)

##### ğŸ“ ì˜ˆì‹œ
- ì´ì „ ìœˆë„(1ë¶„ ì „~0ë¶„ ì „)ì— 5ê±´, í˜„ì¬ ìœˆë„(ì§€ê¸ˆê¹Œì§€) 3ê±´
- ìƒˆ ìš”ì²­ì´ í˜„ì¬ ìœˆë„ì˜ 30% ê²½ê³¼ ì‹œì ì— ë„ì°© â†’ overlapRatio = 1 â€“ 0.3 = 0.7
- ì¶”ì • ìš”ì²­ëŸ‰ = 3 + 5 Ã— 0.7 = 6.5 â†’ ë‚´ë¦¼í•˜ë©´ 6 < 7 â†’ í—ˆìš©

##### âœ… ì¥ì 
- ê³ ì • ìœˆë„ë³´ë‹¤ ì •í™•í•˜ê³ , ë¡œê·¸ ë°©ì‹ë³´ë‹¤ íš¨ìœ¨ì 

##### âš ï¸ ë‹¨ì 
- ì•½ê°„ì˜ ê³„ì‚° ë³µì¡ì„± ì¡´ì¬

```Kotlin
class WeightedSlidingWindowRateLimiter(
    private val windowSizeMillis: Long, // ìœˆë„ìš° í¬ê¸°
    private val maxRequests: Int, // ìœˆë„ìš° ë‚´ í—ˆìš© ìµœëŒ€ ìš”ì²­ ìˆ˜
) {
    // ìœˆë„ìš° ì‹œì‘ ì‹œê°(ë°€ë¦¬ì´ˆ) â†’ ì¹´ìš´í„° ë§µ (ê³ ì • ìœˆë„ìš° ë°©ì‹ ì‚¬ìš©)
    private val counters = ConcurrentHashMap<Long, AtomicInteger>()
    private val lock = ReentrantLock()

    /**
     * ìš”ì²­ í—ˆìš© ì—¬ë¶€ íŒë‹¨ (ì´ë™ ìœˆë„ ê°€ì¤‘ì¹˜ ê³„ì‚° ë°©ì‹)
     *
     * 1) í˜„ì¬ ìœˆë„ìš°ì™€ ë°”ë¡œ ì´ì „ ìœˆë„ìš°ì˜ ì¹´ìš´íŠ¸ ê°€ì ¸ì˜¤ê¸°
     * 2) ì´ì „ ìœˆë„ìš°ê°€ ë‚¨ì•„ ìˆëŠ” ë¹„ìœ¨ë§Œí¼ ê°€ì¤‘ì¹˜ ì ìš©
     * 3) ë‘ ê°’ì„ í•©ì‚°í•œ í›„ í•œë„ ë¹„êµ
     */
    fun allowRequest(): Boolean {
        val now = System.currentTimeMillis()

        // 1) ìœˆë„ìš° ê²½ê³„ ê³„ì‚°
        val currentWindowStart = (now / windowSizeMillis) * windowSizeMillis
        val previousWindowStart = currentWindowStart - windowSizeMillis

        lock.withLock {
            // 2) í˜„ì¬ ë° ì´ì „ ìœˆë„ìš° ìš”ì²­ ìˆ˜ ì¡°íšŒ
            val currentCount = counters[currentWindowStart]?.get() ?: 0
            val previousCount = counters[previousWindowStart]?.get() ?: 0

            // 3) ìœˆë„ìš° ë‚´ ê²½ê³¼/ì”ì—¬ ì‹œê°„ ê³„ì‚°
            val elapsedInCurrent = now - currentWindowStart
            val remainingInCurrent = windowSizeMillis - elapsedInCurrent

            // 4) ì´ì „ ìœˆë„ìš°ì˜ ê°€ì¤‘ì¹˜ ë¹„ìœ¨ (ì”ì—¬ ì‹œê°„ ë¹„ìœ¨)
            val overlapRatio = remainingInCurrent.toDouble() / windowSizeMillis

            // 5) ê°€ì¤‘ í•©ì‚°
            val estimatedRequests = currentCount + (previousCount * overlapRatio)

            // 6) í—ˆìš© ì—¬ë¶€ íŒë‹¨
            return if (estimatedRequests < maxRequests) {
                counters
                    .computeIfAbsent(currentWindowStart) { AtomicInteger(0) }
                    .incrementAndGet()
                true
            } else {
                false
            }
        }
    }
}
```
